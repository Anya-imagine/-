import configparser
import sys
import os
import ipaddress
import json
import urllib.parse
import logging
from dataclasses import dataclass, field
from typing import Optional, Any
from enum import Enum
import functools

from .field import FieldManager
from .session import Session
from analyzers.imports import (
    FieldType,
    FIELD_TYPE_IP_GHASH,
    FIELD_FLAG_CNT,
    FIELD_FLAG_IPPRE,
    FIELD_FLAG_FAKE,
    FIELD_TYPE_STR_HASH,
    FIELD_FLAG_FORCE_UTF8,
    FieldObject,
)
from analyzers import BSB
from scapy.all import sniff, DNS, IP

BSB = BSB.BSB
logger = logging.getLogger(__name__)

MAX_QTYPES = 512
MAX_QCLASSES = 256
MAX_IPS = 2000

DEFAULT_JSON_LEN = 200
HOST_IP_JSON_LEN = 250
ANSWER_JSON_LEN = 200

FNV_OFFSET = 0x811c9dc5 
FNV_PRIME = 0x01000193  

dnsField = 0
dnsHostField = 0
dnsHostMailserverField = 0
dnsHostNameserverField = 0
dnsPunyField = 0
dnsStatusField = 0
dnsOpcodeField = 0
dnsQueryTypeField = 0
dnsQueryClassField = 0
dnsQueryHostField = 0
dnsOutputAnswers = ""
parseDNSRecordAll = 0
root = "<root>"
field_registry = {}

qclasses = []
qtypes = bytearray(MAX_QTYPES)
rcodes = ["NOERROR", "FORMERR", "SERVFAIL", "NXDOMAIN", "NOTIMPL", "REFUSED", 
         "YXDOMAIN", "YXRRSET", "NXRRSET", "NOTAUTH", "NOTZONE", "DSOTYPENI", 
         "12", "13", "14", "15", "BADSIG", "BADKEY", "BADTIME", "BADMODE",
         "BADNAME", "BADALG", "BADTRUNC", "BADCOOKIE"]
opcodes = ["QUERY", "IQUERY", "STATUS", "3", "NOTIFY", "UPDATE", "DSO", "7", 
          "8", "9", "10", "11", "12", "13", "14", "15"]
flagsStr = ["AA", "TC", "RD", "RA", "Z", "AD", "CD"]

# Setup logging
logging.basicConfig(level=logging.INFO)
dns_logger = logging.getLogger("DNS_MODULE")

# Create a decorator to track function calls
def track_dns_calls(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # Print function call info
        session = args[0] if len(args) > 0 else None
        dns_logger.info(f"‚úÖ Ë∞ÉÁî®DNSÂáΩÊï∞: {func.__name__}")
        result = func(*args, **kwargs)
        if result is not None:
            dns_logger.info(f"  - ËøîÂõûÂÄº: {result}")
        return result
    return wrapper

# Add the decorator to all DNS functions
# Find all functions that start with dns_ and apply the decorator
current_module = sys.modules[__name__]
for name in dir(current_module):
    if name.startswith("dns_"):
        func = getattr(current_module, name)
        if callable(func):
            setattr(current_module, name, track_dns_calls(func))

# Keep the original parser_init function
original_parser_init = None
if "parser_init" in dir(current_module):
    original_parser_init = current_module.parser_init

# Override parser_init to report when it's called
@track_dns_calls
def parser_init():
    dns_logger.info("üîÑ ÂàùÂßãÂåñDNSËß£ÊûêÂô®")
    if original_parser_init:
        return original_parser_init()
    return None

# Replace the original parser_init
if original_parser_init:
    current_module.parser_init = parser_init

class Classifier:
    @staticmethod
    def register_port(protocol: str, callback: callable, port: int, port_type: str):
        """
        :param protocol: ÂçèËÆÆÂêçÁß∞Ôºàdns/llmnr/mdnsÔºâ
        :param callback: ÂàÜÁ±ªÂõûË∞ÉÂáΩÊï∞
        :param port: ÁõëÂê¨Á´ØÂè£Âè∑
        :param port_type: Á´ØÂè£Á±ªÂûãÔºåÊîØÊåÅÔºö
            - 'tcp_src'   TCPÊ∫êÁ´ØÂè£
            - 'tcp_dst'   TCPÁõÆÊ†áÁ´ØÂè£
            - 'udp'       UDPÁ´ØÂè£ÔºàÂèåÂêëÔºâ
        """

class DoublyLinkedList:
    def __init__(self):
        self.head = None
        self.tail = None
        self.count = 0  # ÂØπÂ∫îDLL_COUNTÁöÑËÆ°Êï∞Âô®

    def get_count(self):
        """Ëé∑ÂèñÈìæË°®ÂÖÉÁ¥†Êï∞ÈáèÔºåÂØπÂ∫îDLL_COUNTÂÆè"""
        return self.count




class DnsType(Enum):
    DNS_RR_A = 1,
    DNS_RR_NS = 2,
    DNS_RR_CNAME = 5,
    DNS_RR_MX = 15,
    DNS_RR_TXT = 16,
    DNS_RR_AAAA = 28,
    DNS_RR_HTTPS = 65,
    DNS_RR_CAA = 257


class DnsClass(Enum):
    CLASS_IN = 1,
    CLASS_CS = 2,
    CLASS_CH = 3,
    CLASS_HS = 4,
    CLASS_NONE = 254,
    CLASS_ANY = 255,
    CLASS_UNKNOWN = 65280


class DnsSvcbParamKey(Enum):
    SVCB_PARAM_KEY_ALPN = 1
    SVCB_PARAM_KEY_PORT = 3
    SVCB_PARAM_KEY_IPV4_HINT = 4
    SVCB_PARAM_KEY_IPV6_HINT = 6


class DnsResultRecordType(Enum):
    RESULT_RECORD_ANSWER = 1  # Answer or Prerequisites Record
    RESULT_RECORD_AUTHORITATIVE = 2  # Authoritative or Update Record
    RESULT_RECORD_ADDITIONAL = 3  # Additional Record
    RESULT_RECORD_UNKNOWN = 4  # Unknown Record


@dataclass
class DnsAnswerMxrdata:
    preference: int = field(metadata={"range": (0, 65535)})
    exchange: Optional[str] = None

    def preference_range(self):
        if self.preference > 65536 or self.preference < 0:
            raise ValueError("preference must be between 0 and 65535")


@dataclass
class DnsAnswerSvcbRDataFieldValue:
    key: 'DnsSvcbParamKey'
    t_next: Optional['DnsAnswerSvcbRDataFieldValue'] = None
    t_prev: Optional['DnsAnswerSvcbRDataFieldValue'] = None
    value: Any = None


class DnsAnswerSvcbRDataFieldHead:
    t_count: int = 0


@dataclass
class DnsAnswerSvcbRData:
    priority: int = field(metadata={"range": (0, 65535)})
    dname: Optional[str] = None
    fieldValues: Optional['DnsAnswerSvcbRDataFieldHead'] = None

    def priority_range(self):
        if self.priority > 65536 or self.priority < 0:
            raise ValueError("preference must be between 0 and 65535")


@dataclass
class DnsAnswerCaaData:
    flags: int = field(metadata={"range": (0, 255)})
    char: Optional[str] = None
    value: Optional[str] = None


@dataclass
class DnsAnswer:
    ipA: Optional[int] = None
    type_id: Optional[int] = None
    ttl: Optional[int] = None
    class_: Optional[str] = None
    type_: Optional[DnsType] = None
    name: Optional[str] = None
    cname: Optional[str] = None
    mx: Optional[DnsAnswerMxrdata] = None
    nsdname: Optional[str] = None
    ipAAAA: Optional[ipaddress.IPv6Address] = None
    txt: Optional[str] = None
    svcb: Optional[DnsAnswerSvcbRData] = None
    caa: Optional[DnsAnswerCaaData] = None
    t_next: Optional['DnsAnswer'] = None
    t_prev: Optional['DnsAnswer'] = None

    def __post_init__(self):
        # ‰øÆÂ§çÔºöÊ∑ªÂä†NoneÂÄºÊ£ÄÊü•ÔºåÈÅøÂÖç‰∏éNoneËøõË°åÊØîËæÉ
        if self.ipA is not None and not (0 <= self.ipA < 2**32):
            raise ValueError("ipA must be between 0 and 2^32-1")
        elif self.ttl is not None and not (0 <= self.ttl < 2**32):
            raise ValueError("ttl must be between 0 and 2^32-1")
        elif self.type_id is not None and not (0 <= self.type_id < 2**16):
            raise ValueError("type_id must be between 0 and 2^16-1")


class DnsAnswerHead:
    def __init__(self):
        self.t_count = 0
        self.t_head = None
        self.t_prev = None

    def push_tail(self, answer):
        if self.t_count == 0:
            self.t_head = answer
            self.t_prev = answer
        else:
            answer.t_prev = self.t_prev
            answer.t_next = None
            answer.t_prev.t_next = answer
            self.t_prev = answer
        self.t_count += 1
    
    def get_count(self):
        return self.t_count
        
    def __iter__(self):
        """‰ΩøDnsAnswerHeadÂèØËø≠‰ª£Ôºå‰ªét_headÂºÄÂßãÈÅçÂéÜÈìæË°®"""
        current = self.t_head
        while current is not None:
            yield current
            current = getattr(current, 't_next', None)


@dataclass
class DnsQuery:
    class_: Optional[str] = None
    type_: Optional[DnsType] = None
    type_id: Optional[int] = field(metadata={"range": (0, 2**16 - 1)}, default=0)
    class_id: Optional[int] = field(metadata={"range": (0, 2**16 - 1)}, default=0)
    packet_id: Optional[int] = field(metadata={"range": (0, 2**16 - 1)}, default=0)
    opcode_id: Optional[int] = field(metadata={"range": (0, 2**8 - 1)}, default=0)
    opcode: Optional[str] = None
    hostname: Optional[str] = None
    packet_uid: Optional[str] = None

    def __post_init__(self):
        # ‰øÆÂ§çÔºöÊ∑ªÂä†NoneÂÄºÊ£ÄÊü•ÔºåÈÅøÂÖç‰∏éNoneËøõË°åÊØîËæÉ
        if self.type_id is not None and not (0 <= self.type_id < 2**16 - 1):
            raise ValueError("type_id must be between 0 and 2^16-1")
        elif self.class_id is not None and not (0 <= self.class_id < 2**16 - 1):
            raise ValueError("class_id must be between 0 and 2^16-1")
        elif self.packet_id is not None and not (0 <= self.packet_id < 2**16 - 1):
            raise ValueError("packet_id must be between 0 and 2^16-1")
        elif self.opcode_id is not None and not (0 <= self.opcode_id < 2**8 - 1):
            raise ValueError("opcode_id must be between 0 and 2^8-1")


@dataclass
class Dns:
    rcode_id: Optional[int] = field(metadata={"range": (0, 2 ** 8 - 1)})
    headerFlags: Optional[int] = field(metadata={"range": (0, 2 ** 8 - 1)})
    t_next: Optional['Dns'] = None
    t_prev: Optional['Dns'] = None
    query: Optional['DnsQuery'] = None
    answers: Optional['DnsAnswerHead'] = None
    hosts: Optional[dict] = None
    nsHosts: Optional[dict] = None
    mxHosts: Optional[dict] = None
    punyHosts: Optional[dict] = None
    ips: Optional[dict] = None
    nsIPs: Optional[dict] = None
    mxIPs: Optional[dict] = None
    rcode: Optional[str] = None


@dataclass
class DnsHead:
    t_next: Optional['Dns'] = None
    t_prev: Optional['Dns'] = None
    t_count: int = 0


# typedef HASH_VAR(t_, DNSHash_t, DNSHead_t, 1);
# typedef HASH_VAR(t_, DNSHashStd_t, DNSHead_t, 10);

class DnsInfo:
    def __init__(self):
        self.data = [bytearray(1024), bytearray(1024)]  # Âä®ÊÄÅ‰∫åËøõÂà∂ÁºìÂÜ≤Âå∫
        self.size = [1024, 1024]
        self.pos = [0, 0]
        self.length = [0, 0]
        self.query = DnsQuery()

    def __post__init__(self):
        pass

    def __eq__(self, other: object) -> bool:
        """DNS ÂØπË±°‰∫îÁª¥ÁâπÂæÅÁ≤æÁ°ÆÂåπÈÖç"""
        if not isinstance(other, DnsInfo):
            return False

        return (self.query.packet_uid == other.query.packet_uid and
                self.query.opcode_id == other.query.opcode_id and
                self.query.class_id == other.query.class_id and
                self.query.type_id == other.query.type_id and
                self.query.hostname == other.query.hostname)


# ÈáäÊîæDNSËß£ÊûêËøáÁ®ã‰∏≠ÂàÜÈÖçÁöÑËµÑÊ∫ê
def dns_free(session, uw: DnsInfo):
    if uw.data:
        uw.data[0] = None  # ÈáäÊîæËØ∑Ê±ÇÊï∞ÊçÆÁºìÂÜ≤Âå∫
        uw.data[1] = None  # ÈáäÊîæÂìçÂ∫îÊï∞ÊçÆÁºìÂÜ≤Âå∫


def dns_name_element(nbsb: BSB, bsb: BSB) -> int:
    try:
        nlen: int = bsb.read_u8()
        if nlen == 0 or nlen > bsb.remaining():  # Ê£ÄÊü•Ê†áÁ≠æÊúâÊïàÊÄß
            return 1
        for _ in range(nlen):
            c = bsb.read_u8()
            if c > 0x7F:
                nbsb.export_u8(ord('M'))
                nbsb.export_u8(ord('-'))
                c &= 0x7F
            if not (0x20 <= c <= 0x7E):
                nbsb.export_u8(ord('^'))
                c ^= 0x40  # 0x7F^0x40 = 0x3F = ?

            nbsb.export_u8(c)

        return 0
    except:
        return 1


def dns_name(full: bytearray, fulllen: int, inbsb: BSB, name: bytearray, namelen: list):
    didpointer = 0  # ÊåáÈíàË∑≥ËΩ¨ËÆ°Êï∞
    nbsb = BSB(name, len(name))
    tmpbsb = BSB(bytearray(), 0)  # Â§ÑÁêÜÊåáÈíàË∑≥ËΩ¨
    curbsb = inbsb  # ÂàùÂßãÂΩìÂâçÁºìÂÜ≤Âå∫ÊåáÂêëËæìÂÖ•ÁºìÂÜ≤Âå∫

    while curbsb.remaining() > 0:
        ch = curbsb.import_u8()
        if ch == 0:  # ÈÅáÂà∞Á©∫Â≠óÁ¨¶ÁªìÊùü
            break
        curbsb.rewind(1)  # ÂõûÈÄÄ‰∏Ä‰∏™Â≠óËäÇ
        """inbsbÊòØËæìÂÖ•ÔºöÂΩìËæìÂÖ•ÊòØwww.example.comÊó∂ÔºåcurbsbÊòØÊåáÂêëinbsbÁöÑ‰ΩçÁΩÆ
        ÁÑ∂ÂêéchÊòØËØªÂèñÂà∞ËæìÂÖ•ÁºìÂÜ≤Âå∫ÁöÑ‰∏ã‰∏Ä‰∏™Â≠óËäÇÔºåÊâÄ‰ª•Ë¶ÅÂõûÈÄÄ‰∏Ä‰∏™Â≠óËäÇ
        Âèñ‰∫ÜÂ≠óËäÇÁöÑÂâç‰∏§‰ΩçÂÅöÂéãÁº©ÊåáÈíàÁöÑÊ†áÂøó
        """
        if not isinstance(ch, int):
            break

        if ch & 0xc0:  # ÂèñÂâç2‰Ωç11 ÂéãÁº©ÊåáÈíàÊ†áËØÜ
            if didpointer > 5:
                return ''
            didpointer += 1

            tpos = curbsb.import_u16()  # ËØªÂèñÂéãÁº©ÊåáÈíàÁöÑ‰ΩçÁΩÆ
            tpos &= 0x3fff  # ËÆ°ÁÆóÂπ∂‰øùÁïôÂΩìÂâçÁºìÂÜ≤Âå∫ÊåáÈíà‰ΩçÁΩÆÁöÑÂÅèÁßªÈáè
            tmpbsb = BSB(full[tpos:], fulllen - tpos)  # ‰∏¥Êó∂ÁºìÂÜ≤Âå∫ÊåáÂêëÊä•ÊñáËµ∑Âßã‰ΩçÁΩÆ
            curbsb = tmpbsb  # ÊåáÈíàÊåáÂêëÊä•ÊñáËµ∑Âßã‰ΩçÁΩÆ
            continue  # Á´ãÂç≥Â§ÑÁêÜÊñ∞‰ΩçÁΩÆÊï∞ÊçÆ
            """
            ÂéüÂßãÊä•ÊñáÁªìÊûÑÔºö
                +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
                | 3 | w | w | w | 7 | e | x | a | m | p | l | e | 3 | c | o | m | 0 |
                +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
                  ‚ñ≤     ‚ñ≤           ‚ñ≤           ‚ñ≤           ‚ñ≤ 
                  ‚îÇ     ‚îÇ           ‚îÇ           ‚îÇ           ‚îî‚îÄ‚îÄ Á¨¨‰∏â‰∏™ÁªÑ‰ª∂ "com"
                  ‚îÇ     ‚îÇ           ‚îÇ           ‚îÇ           ‚îî‚îÄ‚îÄ Á¨¨‰∫å‰∏™ÁªÑ‰ª∂ "example"
                  ‚îÇ     ‚îÇ           ‚îî‚îÄ‚îÄ Á¨¨‰∏Ä‰∏™ÁªÑ‰ª∂ "www" ÁöÑÈïøÂ∫¶Â≠óËäÇ
                  ‚îÇ     ‚îî‚îÄ‚îÄ Ê†πÁªÑ‰ª∂ÔºàÁ©∫Ê†áÁ≠æÔºåË°®Á§∫ÂüüÂêçÁªìÊùüÔºâ
                  ‚îî‚îÄ‚îÄ ÊâÄÊúâÁªÑ‰ª∂ÁöÑÂ≠òÂÇ®ÁªìÊûÑ
            """
        if nbsb.remaining() > 0:
            nbsb.export_u8(ord('.'))  # ÁªôÊä•ÊñáÊ∑ªÂä†ÂàÜÈöîÁ¨¶
        if not dns_name_element(nbsb, curbsb):
            break
    namelen[0] = nbsb.ptr
    nbsb.export_u8(0)
    return name[:namelen[0]].decode('ascii', 'replace')
    # Â≠óËäÇËΩ¨ÊàêÂ≠óÁ¨¶‰∏≤ËøîÂõû


def dns_parser_rr_svcb(data: bytearray, length: int) -> Optional['DnsAnswerSvcbRData']:
    if length < 10:  # Á°Æ‰øùÊï∞ÊçÆÈïøÂ∫¶Ëá≥Â∞ëÂåÖÊã¨‰ºòÂÖàÁ∫ßÂíåÂàùÂßãÂüüÂêçÈÉ®ÂàÜ
        return None
    svcb_data = DnsAnswerSvcbRData(0)
    svcb_data.fieldValues = DnsAnswerSvcbRDataFieldHead()  # ‰øÆÂ§çÔºöÂàùÂßãÂåñfieldValues
    bsb = BSB(data, length)
    svcb_data.priority = bsb.read_u16()  # ËØªÂèñSVCB_RR‰ºòÂÖàÁ∫ß
    namebuf = bytearray(8000)
    namelen = [len(namebuf)]
    name = dns_name(data, length, bsb, namebuf, namelen)  # Ëß£ÊûêÂüüÂêç
    if bsb.error or not name:
        return None  # ‰øÆÂ§çÔºöÁõ¥Êé•ËøîÂõûNoneÔºåÈÅøÂÖçÂêéÁª≠ËÆøÈóÆsvcb_data
    if not namelen[0]:
        svcb_data.dname = "."  # ËÆæÁΩÆ‰∏∫Ê†πÂüüÂêç
        namelen[0] = 1
    else:
        try:
            svcb_data.dname = name.encode('idna').decode('utf-8')  # ËΩ¨Âåñ‰∏∫IDN
        except UnicodeDecodeError:
            return None
        if not svcb_data.dname:
            return None
    while bsb.remaining() > 4 and not bsb.error:
        key = bsb.read_u16()  # ËØªÂèñSVCBÂ≠óÊÆµÈîÆ
        length = bsb.import_u16()  # ËØªÂèñSVCBÂ≠óÊÆµÂÄºÈïøÂ∫¶
        logger.debug("DNSDEBUG: HTTPS key: %s, len: %s", key, length)  # Ë∞ÉËØïÊó•ÂøóËæìÂá∫
        if length > bsb.remaining():
            return svcb_data
        field_value = DnsAnswerSvcbRDataFieldValue(DnsSvcbParamKey.SVCB_PARAM_KEY_ALPN)
        ptr = bsb.work_ptr()
        match key:
            case DnsSvcbParamKey.SVCB_PARAM_KEY_ALPN:
                field_value.key = DnsSvcbParamKey.SVCB_PARAM_KEY_ALPN
                field_value.value = []
                absb = BSB(ptr, length)
                while absb.remaining() > 1:
                    alen = absb.import_u8()
                    data = absb.import_ptr(alen)
                    if data:
                        apln = data.decode('utf-8', errors='ignore')
                        field_value.value.append(apln)
                        logger.debug("DNSDEBUG: HTTPS ALPN: %s", apln)
            case DnsSvcbParamKey.SVCB_PARAM_KEY_PORT:
                if len != 2:
                    break
                port = ((ptr[0] << 8) | ptr[1])
                field_value.key = DnsSvcbParamKey.SVCB_PARAM_KEY_PORT
                field_value.value = port  # Â≠òÂÇ®Á´ØÂè£Âè∑
                logger.debug("DNSDEBUG: HTTPS PORT: %s", field_value.value)
            case DnsSvcbParamKey.SVCB_PARAM_KEY_IPV4_HINT:
                if len != 4:
                    break
                field_value.key = DnsSvcbParamKey.SVCB_PARAM_KEY_IPV4_HINT
                field_value.value = []
                absb = BSB(ptr, length)
                while absb.remaining() > 3 and not absb.error:
                    data = absb.import_ptr(4)
                    if data:
                        ip = int.from_bytes(data, byteorder='big')
                        ip_str = "%u.%u.%u.%u" % (ip & 0xff, 
                                               (ip >> 8 & 0xff if ip >= 0 else 0), 
                                               (ip >> 16 & 0xff if ip >= 0 else 0), 
                                               (ip >> 24 & 0xff if ip >= 0 else 0))
                        field_value.value.append(ip_str)
                        try:
                            logger.debug("DNSDEBUG: HTTPS IPV4: %u.%u.%u.%u", ip & 0xff, 
                                      (ip >> 8) & 0xff if ip >= 0 else 0, 
                                      (ip >> 16) & 0xff if ip >= 0 else 0, 
                                      (ip >> 24) & 0xff if ip >= 0 else 0)
                        except Exception as e:
                            logger.debug(f"Â§ÑÁêÜIPV4Âú∞ÂùÄÊó∂Âá∫Èîô: {e}, ÂéüÂßãÂÄº: {ip}")
            case DnsSvcbParamKey.SVCB_PARAM_KEY_IPV6_HINT:
                field_value.key = DnsSvcbParamKey.SVCB_PARAM_KEY_IPV6_HINT
                absb = BSB(ptr, length)
                while absb.remaining() > 15 and not absb.error:  # ipv6Âú∞ÂùÄÈïøÂ∫¶‰∏∫16Â≠óËäÇ
                    data = absb.import_ptr(16)
                    if data:
                        ip = ipaddress.IPv6Address(data)
                        field_value.value.append(ip)
                        logger.debug("DNSDEBUG: HTTPS IPV6: %s", ip)
        bsb.skip(length)
        # ‰øÆÊîπÂêéÁöÑÈìæË°®ÊèíÂÖ•Êìç‰Ωú
        if svcb_data.fieldValues.t_count == 0:
            # Á©∫ÈìæË°®ÂàùÂßãÂåñ
            svcb_data.fieldValues.t_next = field_value
            svcb_data.fieldValues.t_prev = field_value
        else:
            # ËøûÊé•Êñ∞ÊóßÂ∞æËäÇÁÇπ
            field_value.t_prev = svcb_data.fieldValues.t_prev
            svcb_data.fieldValues.t_prev.t_next = field_value
            svcb_data.fieldValues.t_prev = field_value
        svcb_data.fieldValues.t_count += 1
    return svcb_data


# Â§ÑÁêÜDNSÂüüÂêçËß£Êûê‰∏≠ÁöÑ‰∏ªÊú∫ÂêçËΩ¨Êç¢„ÄÅÈ™åËØÅÂíåÂ≠òÂÇ®ÈÄªËæë
def dns_add_host(session, dns, hosts, field, uni_set, json_len, string, length):
    if length == -1:
        length = len(string)
    # ËΩ¨Êç¢ÂõΩÈôÖÂåñÂüüÂêç
    try:
        host = string[:length].encode('utf-8').decode('idna')
    except UnicodeError:
        host = None
    if uni_set:  # ËøîÂõûunicodeÂüüÂêç
        uni_set[0] = host
    if host:
        hostlen = len(host)
    if not host or not is_valid_utf8(host):  # ÂüüÂêçÊúâÊïàÊÄßÊ£ÄÊü•
        # Ê∑ªÂä†ÈîôËØØÊ†áÁ≠æ
        if length > 4 and 'xn--' in string[:4]:
            session.add_tag("bad-punnycode")
        else:
            session.add_tag("bad-hostname")
        return 1
    if hosts is not None:
        key = host.lower()
        # Â∞ÜÊúâÊïàÂüüÂêçÊ∑ªÂä†Âà∞ÂìàÂ∏åË°® ÂéªÈáç È´òÈÄü
        if key not in hosts:
            # ÂàùÂßãÂåñÂüüÂêç
            hosts[key] = {
                'str': host,
                'len': len(host),
                'utf8': True
            }
            json_len[0] += HOST_IP_JSON_LEN
    # Â§ÑÁêÜÂåÖÂê´PunycodeÂâçÁºÄÔºàxn--ÔºâÁöÑÂéüÂßãÂüüÂêç
    if length > 4 and string.startswith('xn--'):
        puny_key = string.lower()
        if dns and dns.punyHosts and puny_key not in dns.punyHosts:
            dns.punyHosts[puny_key] = {
                'str': puny_key,
                'len': length
            }
            if session and field:
                session.run_rules(field, puny_key)
    return 0


def is_valid_utf8(s):
    try:
        s.encode('utf-8').decode('utf-8', 'strict')
        return True
    except UnicodeDecodeError:
        return False


def dns_parser(session: Session, kind: int, data: bytearray, length: int, metadata: dict):
    print(f"[Ëß£ÊûêÂô®] Êî∂Âà∞ {length} Â≠óËäÇÊï∞ÊçÆ | Ê∫êIP: {metadata.get('src_ip', 'Êú™Áü•')}")

    # Basic validation: DNS header
    if length < 12:
        print(f"Êó†ÊïàÊï∞ÊçÆÈïøÂ∫¶: {length}")
        return

    # Parse DNS header
    transaction_id = (data[0] << 8) | data[1]
    flags = (data[2] << 8) | data[3]
    qd_count = (data[4] << 8) | data[5]
    an_count = (data[6] << 8) | data[7]
    ns_count = (data[8] << 8) | data[9]
    ar_count = (data[10] << 8) | data[11]

    # Ensure only one query is present
    if qd_count != 1:
        print("‰∏çÊîØÊåÅÂ§ö‰∏™Êü•ËØ¢")
        return

    # Parse the query section
    offset = 12
    qname = []
    while offset < length and data[offset] != 0:
        label_length = data[offset]
        if offset + label_length + 1 >= length:
            print("Êï∞ÊçÆÂåÖ‰∏çÂÆåÊï¥ÊàñÊ†ºÂºèÈîôËØØ")
            return
        try:
            qname.append(data[offset + 1:offset + 1 + label_length].decode('ascii'))
        except UnicodeDecodeError:
            qname.append(data[offset + 1:offset + 1 + label_length].decode('ascii', errors='replace'))
        offset += label_length + 1
    qname = '.'.join(qname)
    offset += 1  # Skip the null byte

    if offset + 4 > length:
        print("Êï∞ÊçÆÂåÖ‰∏çÂÆåÊï¥ÊàñÊ†ºÂºèÈîôËØØ")
        return

    qtype = (data[offset] << 8) | data[offset + 1]
    qclass = (data[offset + 2] << 8) | data[offset + 3]
    offset += 4

    # Store the parsed DNS data in the session
    session.fields['dnsField'] = {
        'transaction_id': transaction_id,
        'flags': flags,
        'qname': qname,
        'qtype': qtype,
        'qclass': qclass,
        'an_count': an_count,
        'ns_count': ns_count,
        'ar_count': ar_count
    }

    print(f"Êü•ËØ¢ÂüüÂêç: {qname}")
    print(f"Êü•ËØ¢Á±ªÂûã: {qtype}")
    print(f"Êü•ËØ¢Á±ª: {qclass}")

# DNS-over-TCPÂçèËÆÆËß£Êûê
def dns_tcp_parser(session,uw,data,length,which):
    if uw.length[which] == 0:
        dns_length=((data[0]&0xff)<<8|(data[1]&0xff)) #Ëß£ÊûêDNSÊ∂àÊÅØÈïøÂ∫¶ÔºàÂ§ßÁ´ØÂ∫èÔºâ
        if dns_length<18: #DNSÂ§¥ÈÉ®ÊúÄÂ∞èÈïøÂ∫¶Ê†°È™åÔºà12Â≠óËäÇÂ§¥ÈÉ®+Ëá≥Â∞ë6Â≠óËäÇÊü•ËØ¢Â≠óÊÆµÔºâ
            session.parser_active=False
            return 0
        #ÂÆåÊï¥Êï∞ÊçÆÂåÖÂ§ÑÁêÜ ÂΩìÂâçTCPÊÆµÂåÖÂê´ÂÆåÊï¥DNSÊ∂àÊÅØ
        if dns_length <= length - 2: #Ê£ÄÊü•Êï∞ÊçÆÂÆåÊï¥ÊÄß
            dns_parser(session, 0, data[2:2+dns_length], dns_length, {'src_ip': '127.0.0.1'}) #Ê∑ªÂä†metadataÂèÇÊï∞
            data = data[2+dns_length:]  # ÁßªÂä®Êï∞ÊçÆÊåáÈíàÔºå‰ΩøÁî®ÂàáÁâáÊìç‰Ωú
            length -= 2 + dns_length #Êõ¥Êñ∞Ââ©‰ΩôÈïøÂ∫¶
            return 1 #Â§ÑÁêÜÂÆåÊàê‰∏Ä‰∏™ÂÆåÊï¥DNSÊ∂àÊÅØ
        #Â§ÑÁêÜÂàÜÁâáÊï∞ÊçÆÔºàÈúÄË¶Å‰øùÂ≠òÈÉ®ÂàÜÊï∞ÊçÆÔºâ
        if uw.size[which] == 0:
            uw.size[which] = max(1024,dns_length) # ÂàÜÈÖçËá≥Â∞ë1KBÊàñÊ∂àÊÅØÈïøÂ∫¶ÁöÑÁ©∫Èó¥
            uw.data[which] = bytearray(uw.size[which]) #Âä®ÊÄÅÂÜÖÂ≠òÂàÜÈÖç
        elif uw.size[which] < dns_length:
            # ‰øÆÂ§çbytearrayË∞ÉÁî®ËØ≠Ê≥ïÔºåÂàÜÈÖç‰∏Ä‰∏™Êñ∞ÁöÑÊõ¥Â§ßÁöÑÁºìÂÜ≤Âå∫
            new_data = bytearray(dns_length)
            # Â¶ÇÊûúÂéüÁºìÂÜ≤Âå∫‰∏≠ÊúâÊï∞ÊçÆÔºåÂàôÂ§çÂà∂Âà∞Êñ∞ÁºìÂÜ≤Âå∫
            if uw.data[which] and uw.pos[which] > 0:
                new_data[:uw.pos[which]] = uw.data[which][:uw.pos[which]]
            uw.data[which] = new_data
            if not uw.data[which]:
                # ÂÜÖÂ≠òÂàÜÈÖçÂ§±Ë¥•Â§ÑÁêÜ
                session.parser_active=False
                return 0
            uw.size[which]=dns_length # Êõ¥Êñ∞ÁºìÂÜ≤Âå∫Â∞∫ÂØ∏
        uw.data[which][:length - 2] = data[2:]  # Â∞Üdata‰ªéÁ¨¨2Â≠óËäÇÂºÄÂßãÂ§çÂà∂Âà∞ÁºìÂÜ≤Âå∫
        uw.length[which]=dns_length # ËÆæÁΩÆÈ¢ÑÊúüÊÄªÈïøÂ∫¶
        uw.pos[which]=length - 2 # ËÆ∞ÂΩïÂ∑≤Êé•Êî∂Êï∞ÊçÆ‰ΩçÁΩÆ
        return 0
    else:
        rem = uw.length[which] - uw.pos[which] #ËÆ°ÁÆóÂâ©‰ΩôÈúÄË¶ÅÁöÑÊï∞ÊçÆÈáè
        if rem <= length:
            uw.data[which][uw.pos[which]:uw.pos[which]+rem] = data[:rem]  # ÊãºË£ÖÂÆåÊï¥Ê∂àÊÅØ
            length -= rem # Êõ¥Êñ∞Ââ©‰ΩôÈïøÂ∫¶
            data = data[rem:] # ÁßªÂä®Êï∞ÊçÆÊåáÈíàÔºå‰ΩøÁî®ÂàáÁâáÊìç‰Ωú
            dns_parser(session, 0, uw.data[which], uw.length[which], {'src_ip': '127.0.0.1'}) #Ê∑ªÂä†metadataÂèÇÊï∞
            uw.length[which] = 0 # ÈáçÁΩÆÂàÜÁâáÁä∂ÊÄÅ
            return 1 # Â§ÑÁêÜÂÆåÊàê‰∏Ä‰∏™ÂÆåÊï¥DNSÊ∂àÊÅØ
        else:
            uw.data[which][uw.pos[which]:uw.pos[which] +length] = data[:length]#ËøΩÂä†ÈÉ®ÂàÜÊï∞ÊçÆ
            uw.pos[which] += length # Êõ¥Êñ∞Â∑≤Êé•Êî∂‰ΩçÁΩÆ
            return 0

# DNS-over-TCPÊµÅÈáèÂ§ÑÁêÜ
def dns_tcp_classify(session,uw,data,length,which):
    # Ê£ÄÊü•ÁõÆÊ†áÁ´ØÂè£ÊòØÂê¶‰∏∫53‰∏î‰ºöËØùÂ∞öÊú™Ê†áËÆ∞DNSÂçèËÆÆ
    if session.port2 == 53 and "dns" not in session.protocols:
        session.protocols.add("dns")  # Ê∑ªÂä†ÂçèËÆÆÊ†áËÆ∞
        info = DnsInfo()
        session.register_parser(dns_tcp_parser, info, dns_free) # Ê≥®ÂÜåTCPËß£ÊûêÂô®

# DNS-over-UDPÊµÅÈáèÂ§ÑÁêÜ
def dns_udp_parser(session,uw,data,length,which):
    #‰ªÖÂ§ÑÁêÜÊú™ÂÖ≥ËÅîÁî®Êà∑Êï∞ÊçÆÊàñÈùûÊ†áÂáÜÁ´ØÂè£ÁöÑUDPÊµÅÈáè
    if uw == 0 or (session.port1 != 53 and session.port2 != 53):
        dns_parser(session, uw, data, length, {'src_ip': '127.0.0.1'}) #Ê∑ªÂä†metadataÂèÇÊï∞
    return 0

# DNS over UDPÊµÅÈáèÊ≥®ÂÜåËß£ÊûêÂô®
def dns_udp_classify(session, data, length, which, uw):
    session.register_parser(dns_udp_parser, uw, 0)
    session.add_protocol("dns")


class JsonSerializer:
    @staticmethod
    def save_string_head(jbsb, head_list, field_name):
        """Â§ÑÁêÜÈìæË°®Á±ªÂûãÊï∞ÊçÆÁªìÊûÑ"""
        if len(head_list) == 0:
            return

        jbsb.export_cstr(f'"{field_name}":[')
        for string in head_list:
            # ÂÆâÂÖ®ÁºñÁ†ÅÂ≠óÁ¨¶‰∏≤Âπ∂Ê∑ªÂä†
            jbsb.export_sprintf("%s,", json.dumps(string.str, ensure_ascii=False))

        # ‰øÆÊ≠£JSONÊ†ºÂºèÔºöÁßªÈô§ÊúÄÂêé‰∏Ä‰∏™ÈÄóÂè∑ÔºåÈó≠ÂêàÊï∞ÁªÑ
        jbsb.rewind(1)
        jbsb.export_cstr("],")

    @staticmethod
    def save_string_hash(jbsb, hash_dict, field_name):
        """Â§ÑÁêÜÂìàÂ∏åË°®Á±ªÂûãÊï∞ÊçÆÁªìÊûÑ"""
        count = len(hash_dict)
        if count == 0:
            return

        jbsb.export_sprintf("\"%sCnt\":%d,", field_name, count)
        jbsb.export_sprintf("\"%s\":[", field_name)

        # ÈÅçÂéÜÂπ∂Ê∏ÖÁ©∫ÂìàÂ∏åË°®
        for key, string in hash_dict.items():
            # ÂÆâÂÖ®ÁºñÁ†ÅÂπ∂Ê∑ªÂä†
            jbsb.export_sprintf("%s,", json.dumps(string.get('str', ''), ensure_ascii=False))
            
        # ‰øÆÊ≠£JSONÊ†ºÂºèÔºöÁßªÈô§ÊúÄÂêé‰∏Ä‰∏™ÈÄóÂè∑ÔºåÈó≠ÂêàÊï∞ÁªÑ
        jbsb.rewind(1)
        jbsb.export_cstr("],")

# IPÂú∞ÂùÄËΩ¨Êç¢‰∏∫JSONÊ†ºÂºè
def dns_save_ip_ghash(jbsb,session:Session,ip_dict,key):
    # # ÁîüÊàêIPËÆ°Êï∞
    count = len(ip_dict)
    if count == 0:
        return
    MAX_IPS = 50
    
    # ÁîüÊàêIPÂàóË°®Êï∞ÁªÑÔºàÂ¶Ç"ip":["1.1.1.1","2606:4700::1111"]Ôºâ
    jbsb.export_cstr(f'"{key}Ct":{count},"{key}":[')
    proceseed = 0
    for ip_bytes in list(ip_dict.keys())[:MAX_IPS]:
        #ËΩ¨Êç¢IPÊ†ºÂºè
        try:
            ip_obj=ipaddress.ip_address(ip_bytes)
            if ip_obj.version == 6 and ip_obj.ipv4_mapped:
                ip_str = str(ip_obj.ipv4_mapped)
            else:
                ip_str = str(ip_obj)
        except:
            ip_str = "invalid_ip"

        jbsb.export_cstr(f'"{ip_str}",')
        
        proceseed += 1
        if proceseed >= MAX_IPS:
            break

    # ‰øÆÊ≠£Êú´Â∞æÈÄóÂè∑
    if jbsb.ptr > 0:
        jbsb.rewind(1)  # ÂõûÈÄÄ‰∏Ä‰∏™Â≠óÁ¨¶ÔºàÈÄóÂè∑Ôºâ
        jbsb.export_cstr("]")
    else:
        jbsb.export_cstr("]")

    # Ê∏ÖÁ©∫ÂéüÂßãÂ≠óÂÖ∏
    ip_dict.clear()

# DNSËß£ÊûêÁªìÊûúËΩ¨Êç¢‰∏∫ÁªìÊûÑÂåñÁöÑJSONÊ†ºÂºè
def dns_save(jbsb,obj:FieldObject,session:Session):
    if obj.objcet is None: #// Á©∫ÂØπË±°Ê£ÄÊü•ÔºàÈò≤Âæ°ÊÄßÁºñÁ®ãÔºâ
        return
    ipAAAA=[]
    Dns.dns=obj.objcet
    jbsb.export_cstr("{") # ÂºÄÂßãÁîüÊàêJSONÂØπË±°Ôºå‰ΩøÁî®export_cstr‰ª£Êõøexport_u8
    
    # ‰ΩøÁî®Ê≠£Á°ÆÁöÑÂ±ûÊÄßÂêçËÆøÈóÆ
    if Dns.dns.query and hasattr(Dns.dns.query, 'hostname'):
        jbsb.export_sprintf("\"queryHost\":\"%s\",", Dns.dns.query.hostname) # Êü•ËØ¢ÂüüÂêç
    
    if Dns.dns.query and hasattr(Dns.dns.query, 'opcode'):
        jbsb.export_sprintf("\"opcode\":\"%s\",", Dns.dns.query.opcode) # DNSÊìç‰ΩúÁ†Å
    
    if Dns.dns.query and hasattr(Dns.dns.query, 'class_id'):
        jbsb.export_sprintf("\"qc\":\"%d\",", Dns.dns.query.class_id) # Êü•ËØ¢Á±ªÂà´ID
    
    if Dns.dns.query and hasattr(Dns.dns.query, 'type_id'):
        jbsb.export_sprintf("\"qt\":\"%d\",", Dns.dns.query.type_id) # Êü•ËØ¢Á±ªÂûãID

    if Dns.dns.hosts:
        # ËæìÂá∫‰∏∫ "host":["example.com","test.com"]
        JsonSerializer.save_string_hash(jbsb,Dns.dns.hosts,"host")
    if Dns.dns.nsHosts:
        # ËæìÂá∫‰∏∫ "nameserverHost":["ns1.example"]
        JsonSerializer.save_string_hash(jbsb,Dns.dns.nsHosts,"nameserverHost")
    if Dns.dns.mxHosts:
        # ËæìÂá∫‰∏∫ "mailserverHost":["mail.example"]
        JsonSerializer.save_string_hash(jbsb,Dns.dns.mxHosts,"mailserverHost")
    if Dns.dns.punyHosts:
        # ËæìÂá∫‰∏∫ "puny":["xn--example.com"]
        JsonSerializer.save_string_hash(jbsb,Dns.dns.punyHosts,"puny")
    if Dns.dns.ips and len(Dns.dns.ips) > 0:
        dns_save_ip_ghash(jbsb, session, Dns.dns.ips, "ip")  # ËæìÂá∫‰∏∫ "ip": ["1.1.1.1"]
        Dns.dns.ips = {}  # ÁΩÆÁ©∫Èò≤Ê≠¢ÈáçÂ§çÂ§ÑÁêÜ
    if Dns.dns.nsIPs and len(Dns.dns.nsIPs) > 0:
        dns_save_ip_ghash(jbsb, session, Dns.dns.nsIPs, "nameserverIP") # // ËæìÂá∫‰∏∫ "nameserverIp": ["9.9.9.9"]
        Dns.dns.nsIPs = {}
    if Dns.dns.mxIPs and len(Dns.dns.mxIPs) > 0:
        dns_save_ip_ghash(jbsb, session, Dns.dns.mxIPs, "mailserverIP") # // ËæìÂá∫‰∏∫ "mailserverIp":
        Dns.dns.mxIPs = {}
    if Dns.dns.headerFlags:
        jbsb.export_cstr("\"headerFlags\": [")
        #ÈÅçÂéÜDNSÂ§¥ÈÉ®ÁöÑ7‰∏™Ê†áÂøó‰ΩçÔºà‰ªéÊúÄÈ´ò‰ΩçQRÂà∞ÊúÄ‰Ωé‰ΩçRAÔºâ
        for i in range(0,7):
            # Ê£ÄÊü•Á¨¨(6-i)‰ΩçÊòØÂê¶ÁΩÆ‰ΩçÔºà‰æãÂ¶Çi=0Êó∂Ê£ÄÊü•Á¨¨6‰ΩçQRÊ†áÂøóÔºâ
            if Dns.dns.headerFlags & (1 << (6 - i)):
                # Ê∑ªÂä†ÂØπÂ∫îÁöÑÊ†áÂøóÂ≠óÁ¨¶‰∏≤ÔºàÂ¶ÇQR/AA/TCÁ≠âÔºâ
                jbsb.export_sprintf("\"%s\",", flagsStr[i])
        # ‰øÆÊ≠£JSONÊ†ºÂºèÔºöÁßªÈô§ÊúÄÂêé‰∏Ä‰∏™ÈÄóÂè∑ÔºåÈó≠ÂêàÊï∞ÁªÑ
        jbsb.rewind(1)
        jbsb.export_cstr("],")

    #Â§ÑÁêÜDNSÂìçÂ∫îÁä∂ÊÄÅÁ†ÅÂíåÂ∫îÁ≠îËÆ∞ÂΩï
    if Dns.dns.rcode_id != -1:
        #  Â∫èÂàóÂåñÂìçÂ∫îÁä∂ÊÄÅÔºàÂ¶ÇNOERROR / SERVFAILÔºâ
        jbsb.export_sprintf("\"status\":\"%s\",", Dns.dns.rcode)
        if dnsOutputAnswers: #ÈÖçÁΩÆÂÖÅËÆ∏ËæìÂá∫Â∫îÁ≠îËÆ∞ÂΩïÊó∂
            #ÁîüÊàêÂ∫îÁ≠îÊÄªÊï∞Â≠óÊÆµÔºàÂ¶Ç"answersCnt":3Ôºâ
            if Dns.dns.answers and hasattr(Dns.dns.answers, 'get_count'):
                answers_count = Dns.dns.answers.get_count()
                jbsb.export_sprintf("\"answersCnt\":%d,", answers_count)
                if answers_count > 0:
                    jbsb.export_cstr("\"answers\":[") # ÂºÄÂßãÂ∫îÁ≠îÊï∞ÁªÑ
                    #ÈÅçÂéÜDNSÂ∫îÁ≠îËÆ∞ÂΩï
                    for answer in Dns.dns.answers:
                        jbsb.export_cstr("{") # ÂºÄÂßãÂ∫îÁ≠îÂØπË±°
                        match answer.type_id:
                            case DnsType.DNS_RR_A:
                                #Â§ÑÁêÜAËÆ∞ÂΩïÔºàIPv4Âú∞ÂùÄÔºâ,Â∞Ü IP Âú∞ÂùÄ‰ø°ÊÅØ‰ª• JSON ÈîÆÂÄºÂØπÂΩ¢ÂºèÂÜôÂÖ• BSB ÁºìÂÜ≤Âå∫
                                try:
                                    if answer.ipA is not None and isinstance(answer.ipA, int) and answer.ipA >= 0:
                                        ip_str = f"\"ipA\":\"{(answer.ipA >> 24) & 0xff}.{(answer.ipA >> 16) & 0xff}.{(answer.ipA >> 8) & 0xff}.{answer.ipA & 0xff}\","
                                        jbsb.export_sprintf(ip_str)
                                    else:
                                        # Â¶ÇÊûúIPÂú∞ÂùÄ‰∏∫Ë¥üÊï∞ÊàñNoneÔºå‰ΩøÁî®ÂÆâÂÖ®Ê†ºÂºè
                                        jbsb.export_sprintf("\"ip\":\"0.0.0.0\",")
                                        logger.debug(f"Êó†ÊïàÁöÑIPv4Âú∞ÂùÄÂÄº: {answer.ipA}")
                                except Exception as e:
                                    # ÊçïËé∑ÊâÄÊúâÂºÇÂ∏∏Âπ∂Êèê‰æõÂÆâÂÖ®ËæìÂá∫
                                    jbsb.export_sprintf("\"ip\":\"0.0.0.0\",")
                                    logger.debug(f"Â§ÑÁêÜIPv4Âú∞ÂùÄÊó∂Âá∫Èîô: {e}")
                                break
                            case DnsType.DNS_RR_NS:
                                jbsb.export_sprintf("\"nameserver\":\"%s\",", answer.nsdname)
                                break
                            case DnsType.DNS_RR_CNAME:
                                jbsb.export_sprintf("\"cname\":\"%s\",", answer.cname)
                                break
                            case DnsType.DNS_RR_MX:
                                jbsb.export_sprintf("\"priority\":%u,\"mx\":\"%s\",", answer.mx.preference,answer.mx.exchange)
                                break
                            case DnsType.DNS_RR_AAAA:
                                #Â§ÑÁêÜAAAAËÆ∞ÂΩïÔºàIPv6Âú∞ÂùÄÔºâ
                                if isinstance(answer.ipAAAA, ipaddress.IPv6Address):
                                    if answer.ipAAAA.ipv4_mapped:
                                        # ÊèêÂèñÂÜÖÂµåÁöÑ IPv4 Âú∞ÂùÄÂπ∂Ê†ºÂºèÂåñ‰∏∫ÁÇπÂàÜÂçÅËøõÂà∂
                                        ipv4_str = str(answer.ipAAAA.ipv4_mapped)
                                        jbsb.export_sprintf("\"ip\":\"%s\",", ipv4_str)
                                    else:
                                        # Á∫Ø IPv6 Âú∞ÂùÄÁõ¥Êé•ËΩ¨Êç¢‰∏∫Â≠óÁ¨¶‰∏≤
                                        ipv6_str = str(answer.ipAAAA)
                                        jbsb.export_sprintf("\"ip\":\"%s\",", ipv6_str)
                                break
                            case DnsType.DNS_RR_TXT:
                                if answer.txt:
                                    # Ëß£Á†ÅÂ≠óËäÇÊï∞ÊçÆÂπ∂ËΩ¨‰πâÁâπÊÆäÂ≠óÁ¨¶
                                    txt_str = answer.txt.decode('utf-8', errors='replace').strip()
                                    jbsb.export_sprintf("\"txt\":%s,", json.dumps(txt_str))
                                break
                            case DnsType.DNS_RR_HTTPS:
                                # Ëß£Á†ÅÂéüÂßãÂÄºÂπ∂ÊâßË°åURLÂÆâÂÖ®ÁºñÁ†Å
                                value_str = answer.caa.value.decode('utf-8', errors='replace').strip()
                                encoded_value = urllib.parse.quote(value_str, safe='')
                                jbsb.export_sprintf("\"caa\":\"CAA %d %s %s\",",
                                                    answer.caa.flags, answer.caa.tag, encoded_value)
                                jbsb.export_sprintf("\",")
                                break
                        if answer.class_:
                            jbsb.export_sprintf("\"class\":\"%s\",", answer.class_) #ËµÑÊ∫êËÆ∞ÂΩïÁ±ªÔºàÂ¶ÇINÔºâ
                        if answer.type:
                            jbsb.export_sprintf("\"type\":\"%s\",", answer.type) # ËµÑÊ∫êËÆ∞ÂΩïÁ±ªÂûãÔºàÂ¶ÇA/AAAAÔºâ
                        jbsb.export_sprintf("\"ttl\":%u,", answer.ttl)
                        jbsb.export_sprintf("\"name\":\"%s\",", answer.name) # ÂüüÂêç
                        if answer.name and answer.name != root:
                            answer.name = None
                        jbsb.rewind(1)
                        jbsb.export_cstr("}") # ‰ΩøÁî®export_cstr‰ª£Êõøexport_u8
                        jbsb.export_cstr(",") # ‰ΩøÁî®export_cstr‰ª£Êõøexport_u8
                    jbsb.rewind(1)
                    jbsb.export_cstr("}")  # Èó≠ÂêàJSONÂØπË±°Ôºå‰ΩøÁî®export_cstr

# È´òÊïàÂ≠òÂÇ®ÂíåÊ£ÄÁ¥¢DNSËÆ∞ÂΩï
def dns_hash(*args):
    from .singleton import field_manager
    # Implementation...

# Êî∂ÈõÜDNS‰ºöËØù‰∏≠ÁöÑÊâÄÊúâÁõ∏ÂÖ≥‰∏ªÊú∫Âêç
def dns_getcb_host(session: Session) -> set:
    if not session.fields.get('dnsField'):
        return set()

    host_set = set()

    # ÈÅçÂéÜÊâÄÊúâDNSÂØπË±°
    dns_data = session.fields.get('dnsField')
    
    # Áõ¥Êé•ËÆøÈóÆFieldObjectÁöÑÂ±ûÊÄß
    try:
        # Â¶ÇÊûúÊòØÊ†áÂáÜÂØπË±°ÈõÜÂêà
        if hasattr(dns_data, 'objects') and dns_data.objects:
            for dns_obj in dns_data.objects.values():
                dns = dns_obj.object
                # Ê∑ªÂä†Êü•ËØ¢‰∏ªÊú∫Âêç
                if dns.query and dns.query.hostname:
                    host_set.add(dns.query.hostname)

                # Ê∑ªÂä†ÂêÑÁ±ªËÆ∞ÂΩï‰∏≠ÁöÑ‰∏ªÊú∫Âêç
                for hash_table in [dns.hosts, dns.nsHosts, dns.mxHosts]:
                    if hash_table:
                        host_set.update(hash_table.keys())
        # Â¶ÇÊûúÊòØÁõ¥Êé•Â≠òÂÇ®ÁöÑÁÆÄÂçïÂ≠óÂÖ∏Êï∞ÊçÆ
        elif hasattr(dns_data, 'qname') and dns_data.qname:
            host_set.add(dns_data.qname)
        # Â∞ùËØï‰Ωú‰∏∫Â≠óÂÖ∏ËÆøÈóÆ
        elif isinstance(dns_data, dict) and 'qname' in dns_data:
            host_set.add(dns_data['qname'])
    except (AttributeError, TypeError):
        # ÊçïËé∑‰ªª‰ΩïËÆøÈóÆÈîôËØØ
        pass

    return host_set

# Êî∂ÈõÜ‰ºöËØù‰∏≠ÊâÄÊúâÈÇÆ‰ª∂ÊúçÂä°Âô®‰∏ªÊú∫Âêç
def dns_getcb_host_mailserver(session: Session) -> set:
    if not session.fields.get('dnsField'):
        return set()

    mail_set = set()

    # ÈÅçÂéÜÊâÄÊúâDNSÂØπË±°
    dns_data = session.fields.get('dnsField')
    
    try:
        # Â¶ÇÊûúÊòØFieldObjectÂØπË±°
        if hasattr(dns_data, 'object') and dns_data.object:
            dns = dns_data.object
            # Â§ÑÁêÜMXËÆ∞ÂΩï‰∏≠ÁöÑ‰∏ªÊú∫Âêç
            if hasattr(dns, 'mxHosts') and dns.mxHosts:
                mail_set.update(dns.mxHosts.keys())
        # Â¶ÇÊûúÊòØÊ†áÂáÜÂØπË±°ÈõÜÂêà
        elif hasattr(dns_data, 'objects') and dns_data.objects:
            for dns_obj in dns_data.objects.values():
                dns = dns_obj.object
                # ‰ªÖÂ§ÑÁêÜMXËÆ∞ÂΩï‰∏≠ÁöÑ‰∏ªÊú∫Âêç
                if hasattr(dns, 'mxHosts') and dns.mxHosts:
                    mail_set.update(dns.mxHosts.keys())
        # Áõ¥Êé•ËÆøÈóÆÂ≠óÂÖ∏
        elif isinstance(dns_data, dict) and 'mail_servers' in dns_data:
            mail_servers = dns_data.get('mail_servers')
            if isinstance(mail_servers, list):
                mail_set.update(mail_servers)
            elif isinstance(mail_servers, dict):
                mail_set.update(mail_servers.keys())
    except (AttributeError, TypeError):
        # ÊçïËé∑‰ªª‰ΩïËÆøÈóÆÈîôËØØ
        pass

    return mail_set

"""Êî∂ÈõÜ‰ºöËØù‰∏≠ÊâÄÊúâÊùÉÂ®ÅÂêçÁß∞ÊúçÂä°Âô®‰∏ªÊú∫Âêç"""
def dns_getcb_host_nameserver(session: Session) -> set:
    if not session.fields.get('dnsField'):
        return set()

    nameserver_set = set()

    # ÈÅçÂéÜÊâÄÊúâDNSÂØπË±°
    dns_data = session.fields.get('dnsField')
    
    try:
        # Â¶ÇÊûúÊòØFieldObjectÂØπË±°
        if hasattr(dns_data, 'object') and dns_data.object:
            dns = dns_data.object
            # Â§ÑÁêÜNSËÆ∞ÂΩï‰∏≠ÁöÑ‰∏ªÊú∫Âêç
            if hasattr(dns, 'nsHosts') and dns.nsHosts:
                nameserver_set.update(dns.nsHosts.keys())
        # Â¶ÇÊûúÊòØÊ†áÂáÜÂØπË±°ÈõÜÂêà
        elif hasattr(dns_data, 'objects') and dns_data.objects:
            for dns_obj in dns_data.objects.values():
                dns = dns_obj.object
                # ‰ªÖÂ§ÑÁêÜNSËÆ∞ÂΩï‰∏≠ÁöÑ‰∏ªÊú∫Âêç
                if hasattr(dns, 'nsHosts') and dns.nsHosts:
                    nameserver_set.update(dns.nsHosts.keys())
        # Áõ¥Êé•ËÆøÈóÆÂ≠óÂÖ∏
        elif isinstance(dns_data, dict) and 'name_servers' in dns_data:
            name_servers = dns_data.get('name_servers')
            if isinstance(name_servers, list):
                nameserver_set.update(name_servers)
            elif isinstance(name_servers, dict):
                nameserver_set.update(name_servers.keys())
    except (AttributeError, TypeError):
        # ÊçïËé∑‰ªª‰ΩïËÆøÈóÆÈîôËØØ
        pass

    return nameserver_set

"""Êî∂ÈõÜ‰ºöËØù‰∏≠ÊâÄÊúâPunycodeÁºñÁ†ÅÂüüÂêç"""
def dns_getcb_puny(session: Session) -> set:
    if not session.fields.get('dnsField'):
        return set()

    puny_set = set()

    # ÈÅçÂéÜÊâÄÊúâDNSÂØπË±°
    dns_data = session.fields.get('dnsField')
    
    try:
        # Â¶ÇÊûúÊòØFieldObjectÂØπË±°
        if hasattr(dns_data, 'object') and dns_data.object:
            dns = dns_data.object
            # Â§ÑÁêÜPunycodeÁºñÁ†ÅÂüüÂêç
            if hasattr(dns, 'punyHosts') and dns.punyHosts:
                puny_set.update(dns.punyHosts.keys())
        # Â¶ÇÊûúÊòØÊ†áÂáÜÂØπË±°ÈõÜÂêà
        elif hasattr(dns_data, 'objects') and dns_data.objects:
            for dns_obj in dns_data.objects.values():
                dns = dns_obj.object
                # ‰ªÖÂ§ÑÁêÜPunycodeÁºñÁ†ÅÂüüÂêç
                if hasattr(dns, 'punyHosts') and dns.punyHosts:
                    puny_set.update(dns.punyHosts.keys())
        # Áõ¥Êé•ËÆøÈóÆÂ≠óÂÖ∏
        elif isinstance(dns_data, dict) and 'puny_hosts' in dns_data:
            puny_hosts = dns_data.get('puny_hosts')
            if isinstance(puny_hosts, list):
                puny_set.update(puny_hosts)
            elif isinstance(puny_hosts, dict):
                puny_set.update(puny_hosts.keys())
    except (AttributeError, TypeError):
        # ÊçïËé∑‰ªª‰ΩïËÆøÈóÆÈîôËØØ
        pass

    return puny_set

"""Êî∂ÈõÜ‰ºöËØù‰∏≠ÊâÄÊúâDNSÂìçÂ∫îÁä∂ÊÄÅÁ†Å"""
def dns_getcb_status(session: Session) -> set:
    if not session.fields.get('dnsField'):
        return set()

    status_set = set()

    # ÈÅçÂéÜÊâÄÊúâDNSÂØπË±°
    dns_data = session.fields.get('dnsField')
    
    try:
        # Â¶ÇÊûúÊòØFieldObjectÂØπË±°
        if hasattr(dns_data, 'object') and dns_data.object:
            dns = dns_data.object
            # Êî∂ÈõÜÂìçÂ∫îÁä∂ÊÄÅÁ†ÅÔºàÂ¶Ç NOERROR„ÄÅSERVFAILÔºâ
            if hasattr(dns, 'rcode') and dns.rcode:
                status_set.add(dns.rcode)
        # Â¶ÇÊûúÊòØÊ†áÂáÜÂØπË±°ÈõÜÂêà
        elif hasattr(dns_data, 'objects') and dns_data.objects:
            for dns_obj in dns_data.objects.values():
                dns = dns_obj.object
                # Êî∂ÈõÜÂìçÂ∫îÁä∂ÊÄÅÁ†ÅÔºàÂ¶Ç NOERROR„ÄÅSERVFAILÔºâ
                if hasattr(dns, 'rcode') and dns.rcode:
                    status_set.add(dns.rcode)
        # Áõ¥Êé•ËÆøÈóÆÂ≠óÂÖ∏
        elif isinstance(dns_data, dict) and 'status' in dns_data:
            status = dns_data.get('status')
            if status:
                status_set.add(status)
    except (AttributeError, TypeError):
        # ÊçïËé∑‰ªª‰ΩïËÆøÈóÆÈîôËØØ
        pass

    return status_set

"""Êî∂ÈõÜ‰ºöËØù‰∏≠ÊâÄÊúâDNSÊìç‰ΩúÁ†Å"""
def dns_getcb_opcode(session: Session) -> set:
    if not session.fields.get('dnsField'):
        return set()

    opcode_set = set()

    # ÈÅçÂéÜÊâÄÊúâDNSÂØπË±°
    dns_data = session.fields.get('dnsField')
    
    try:
        # Â¶ÇÊûúÊòØFieldObjectÂØπË±°
        if hasattr(dns_data, 'object') and dns_data.object:
            dns = dns_data.object
            # Êî∂ÈõÜÊìç‰ΩúÁ†Å
            if hasattr(dns, 'query') and dns.query and hasattr(dns.query, 'opcode') and dns.query.opcode:
                opcode_set.add(dns.query.opcode)
        # Â¶ÇÊûúÊòØÊ†áÂáÜÂØπË±°ÈõÜÂêà
        elif hasattr(dns_data, 'objects') and dns_data.objects:
            for dns_obj in dns_data.objects.values():
                dns = dns_obj.object
                # Êî∂ÈõÜÊìç‰ΩúÁ†ÅÔºàÂ¶Ç QUERY„ÄÅSTATUSÔºâ
                if hasattr(dns, 'query') and dns.query and hasattr(dns.query, 'opcode') and dns.query.opcode:
                    opcode_set.add(dns.query.opcode)
        # Áõ¥Êé•ËÆøÈóÆÂ≠óÂÖ∏
        elif isinstance(dns_data, dict) and 'opcode' in dns_data:
            opcode = dns_data.get('opcode')
            if opcode:
                opcode_set.add(opcode)
    except (AttributeError, TypeError):
        # ÊçïËé∑‰ªª‰ΩïËÆøÈóÆÈîôËØØ
        pass

    return opcode_set

"""Êî∂ÈõÜ‰ºöËØù‰∏≠ÊâÄÊúâDNSÊü•ËØ¢Á±ªÂûã"""
def dns_getcb_query_type(session: Session) -> set:
    if not session.fields.get('dnsField'):
        return set()

    query_type_set = set()

    # ÈÅçÂéÜÊâÄÊúâDNSÂØπË±°
    dns_data = session.fields.get('dnsField')
    
    try:
        # Â¶ÇÊûúÊòØÊ†áÂáÜÂØπË±°ÈõÜÂêà
        if hasattr(dns_data, 'objects') and dns_data.objects:
            for dns_obj in dns_data.objects.values():
                dns = dns_obj.object
                # Êî∂ÈõÜÊü•ËØ¢Á±ªÂûãÔºàÂ¶Ç A„ÄÅAAAA„ÄÅMXÔºâ
                if dns.query and dns.query.type:
                    query_type_set.add(dns.query.type)
        # Â∞ùËØïÂ±ûÊÄßËÆøÈóÆ
        elif hasattr(dns_data, 'qtype'):
            qtype = dns_data.qtype
            if isinstance(qtype, int):
                # Â∞ùËØïÂ∞ÜÊï¥Êï∞ËΩ¨Êç¢‰∏∫Êõ¥ÂèãÂ•ΩÁöÑË°®Á§∫
                if qtype == 1:
                    query_type_set.add('A')
                elif qtype == 28:
                    query_type_set.add('AAAA')
                else:
                    query_type_set.add(str(qtype))
            elif qtype:
                query_type_set.add(str(qtype))
        # Â∞ùËØïÂ≠óÂÖ∏ËÆøÈóÆ
        elif isinstance(dns_data, dict) and 'qtype' in dns_data:
            qtype = dns_data['qtype']
            if isinstance(qtype, int):
                if qtype == 1:
                    query_type_set.add('A')
                elif qtype == 28:
                    query_type_set.add('AAAA')
                else:
                    query_type_set.add(str(qtype))
            elif qtype:
                query_type_set.add(str(qtype))
    except (AttributeError, TypeError):
        # ÊçïËé∑‰ªª‰ΩïËÆøÈóÆÈîôËØØ
        pass

    return query_type_set

"""Êî∂ÈõÜ‰ºöËØù‰∏≠ÊâÄÊúâDNSÊü•ËØ¢Á±ª"""
def dns_getcb_query_class(session: Session) -> set:
    if not session.fields.get('dnsField'):
        return set()

    query_class_set = set()

    # ÈÅçÂéÜÊâÄÊúâDNSÂØπË±°
    dns_data = session.fields.get('dnsField')
    
    try:
        # Â¶ÇÊûúÊòØÊ†áÂáÜÂØπË±°ÈõÜÂêà
        if hasattr(dns_data, 'objects') and dns_data.objects:
            for dns_obj in dns_data.objects.values():
                dns = dns_obj.object
                # Êî∂ÈõÜÊü•ËØ¢Á±ªÔºàÂ¶Ç IN„ÄÅCH„ÄÅHSÔºâ
                if dns.query and dns.query.class_:
                    query_class_set.add(dns.query.class_)
        # Â∞ùËØïÂ±ûÊÄßËÆøÈóÆ
        elif hasattr(dns_data, 'qclass'):
            qclass = dns_data.qclass
            if isinstance(qclass, int):
                # Â∞ùËØïÂ∞ÜÊï¥Êï∞ËΩ¨Êç¢‰∏∫Êõ¥ÂèãÂ•ΩÁöÑË°®Á§∫
                if qclass == 1:
                    query_class_set.add('IN')
                else:
                    query_class_set.add(str(qclass))
            elif qclass:
                query_class_set.add(str(qclass))
        # Â∞ùËØïÂ≠óÂÖ∏ËÆøÈóÆ
        elif isinstance(dns_data, dict) and 'qclass' in dns_data:
            qclass = dns_data['qclass']
            if isinstance(qclass, int):
                if qclass == 1:
                    query_class_set.add('IN')
                else:
                    query_class_set.add(str(qclass))
            elif qclass:
                query_class_set.add(str(qclass))
    except (AttributeError, TypeError):
        # ÊçïËé∑‰ªª‰ΩïËÆøÈóÆÈîôËØØ
        pass

    return query_class_set

"""Êî∂ÈõÜ‰ºöËØù‰∏≠ÊâÄÊúâDNSÊü•ËØ¢ÂüüÂêç"""
def dns_getcb_query_host(session: Session) -> set:
    if not session.fields.get('dnsField'):
        return set()

    host_set = set()

    # ÈÅçÂéÜÊâÄÊúâDNSÂØπË±°
    dns_data = session.fields.get('dnsField')
    
    try:
        # Â¶ÇÊûúÊòØÊ†áÂáÜÂØπË±°ÈõÜÂêà
        if hasattr(dns_data, 'objects') and dns_data.objects:
            for dns_obj in dns_data.objects.values():
                dns = dns_obj.object
                # Êî∂ÈõÜÊü•ËØ¢ÂüüÂêçÔºà‰øùÁïôÂ§ßÂ∞èÂÜôÊïèÊÑüÔºâ
                if dns.query and dns.query.hostname:
                    host_set.add(dns.query.hostname)
        # Â∞ùËØïÂ±ûÊÄßËÆøÈóÆ
        elif hasattr(dns_data, 'qname') and dns_data.qname:
            host_set.add(dns_data.qname)
        # Â∞ùËØïÂ≠óÂÖ∏ËÆøÈóÆ
        elif isinstance(dns_data, dict) and 'qname' in dns_data:
            host_set.add(dns_data['qname'])
    except (AttributeError, TypeError):
        # ÊçïËé∑‰ªª‰ΩïËÆøÈóÆÈîôËØØ
        pass

    return host_set

def field_object_register(name, description, save_func, hash_func,cmp_func):
    """Ê®°ÊãüÂ≠óÊÆµÂØπË±°Ê≥®ÂÜå"""
    field_registry[name] = {
        'save': save_func,
        'hash': hash_func,
        'cmp': cmp_func,
        'description': description
    }
    return name  # ËøîÂõûÂ≠óÊÆµÂêçÁß∞‰Ωú‰∏∫Ê†áËØÜÁ¨¶
